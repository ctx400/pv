'''# The PV Secrets Vault

Copyright (c) 2025 @ctx400. All rights reserved.

Licensed for use under the terms of the MIT license.
(https://opensource.org/license/mit)

A simple, secure vault for storing arbitrary secrets, serializable to
JSON, and easy to integrate into other projects.

## Basic Usage Recipies

```py
from pv import PV

# Create a new vault
pv = PV.init('master_password')
pv.save('pv.json')

# Load an existing vault
pv = PV.load('pv.json')

# Create new secrets
pv.store_secret('mykey', 'mysecret', 'master_password')
pv.store_secret('google', 'mygooglepassword123', 'master_password')
pv.save('pv.json')

# List all secrets
print(pv.list_secrets())

# Read a secret
print(pv.read_secret('mykey', 'master_password'))

# Delete a secret
pv.delete_secret('mykey')
```
'''

# stdlib imports
import json as _json
import secrets as _secrets
from pathlib import Path as _Path
from base64 import urlsafe_b64encode as _urlsafe_b64encode
from base64 import urlsafe_b64decode as _urlsafe_b64decode
from typing import Optional as _Optional

# 3rd-party imports
from cattrs import structure as _structure
from cattrs import unstructure as _unstructure
from attrs import define as _define
from attrs import field as _field
from attrs import Factory as _Factory
from cryptography.fernet import Fernet as _Fernet
from cryptography.hazmat.primitives.kdf.argon2 import Argon2id as _Argon2id

#
# Export Control
#
__all__ = [
    # This Module
    'PV',
    'MasterKey',
    'Secret',
    'Argon2idKDF',
    'new_salt',

    # Other Modules
    'cli', #type:ignore - For pdoc's sake
]

PV_VERSION: int = 2
'''Current PV major version.

This version number will increase after any breaking change to the
vault structure or its operation.
'''


def new_salt(length: int = 16) -> str:
    '''Generates a base64-encoded random salt.'''

    salt: bytes = _secrets.token_bytes(length)
    encoded: bytes = _urlsafe_b64encode(salt)
    return encoded.decode()


@_define(frozen=True)
class Argon2idKDF:
    '''Argon2id Key Deriviation Function (KDF).

    PV uses Argon2id, a very strong hash function
    designed intentionally to be very slow, very memory intensive,
    and very compute expensive. This makes it an ideal choice for
    brute-force and dictionary-resistant password hashing and
    cryptographic key derivation.

    These parameter values are secure by default, however, the end-user
    is free to tune them to their liking. However, it is **strongly**
    recommended not to change parameters if you don't know what you're
    doing.

    **REFERENCE**: Secure defaults are from OWASP. See the
    [OWASP CheatSheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#argon2id)
    for quick reference.
    '''

    memory_cost: int = _field(default=94208)
    '''Memory to use per hashing operation, in Kibibytes (KiB).

    Greater memory usage makes it more difficult to run
    password-cracking operations.
    '''

    iterations: int = _field(default=2)
    '''Number of hashing rounds to perform.

    A greater number of iterations increases the time it takes to
    compute a hash, slowing down adversaries.
    '''

    parallelism: int = _field(default=1)
    '''Number of parallel threads to use.
    It is recommended to keep this value low.
    '''

    def derive(self, password: bytes, salt: bytes) -> bytes:
        '''Generate an encryption derivation key.

        Make sure you are using a securely-generated, random, and unique
        salt value, such as generated by the `new_salt()` function.

        It is recommended to use a long, complex master password, or a
        passphrase consisting of at least 6-8 random words. Always use
        best practices for choosing a password.
        '''

        kdf = _Argon2id(
            salt=salt,
            memory_cost=self.memory_cost,
            iterations=self.iterations,
            lanes=self.parallelism,
            length=32,
        )
        derived_key: bytes = kdf.derive(password)
        encoded_key: bytes = _urlsafe_b64encode(derived_key)
        return encoded_key


@_define(frozen=True)
class Secret:
    '''An encrypted secret stored in a PV database.'''

    secret: str = _field()
    '''The secret to encrypt/decrypt.'''

    def seal(self, fernet: _Fernet) -> 'Secret':
        '''Returns an encrypted (sealed) `Secret` instance.'''

        # Encrypt the secret.
        encrypted_secret: bytes = fernet.encrypt(self.secret.encode())

        # Serialize and decode the secret.
        serialized_secret: bytes = _urlsafe_b64encode(encrypted_secret)
        decoded_secret: str = serialized_secret.decode()

        # Return the sealed secret.
        return Secret(decoded_secret)

    def unseal(self, fernet: _Fernet) -> 'Secret':
        '''Returns a plaintext (unsealed) `Secret` instance.'''

        # Encode and deserialize the secret.
        encoded_secret: bytes = self.secret.encode()
        deserialized_secret: bytes = _urlsafe_b64decode(encoded_secret)

        # Decrypt and decode the secret.
        plaintext_secret: bytes = fernet.decrypt(deserialized_secret)
        decoded_secret: str = plaintext_secret.decode()

        # Return the unsealed secret.
        return Secret(decoded_secret)


@_define(frozen=True)
class MasterKey:
    '''Master encryption key for the vault.'''

    seal: str = _field()
    '''The encrypted master key.

    The vault's master key is protected by the master password. It in
    turn protects all secrets stored in the vault. It is strongly
    recommended to use `MasterKey.create()` instead of specifying this
    manually!
    '''

    salt: str = _Factory(new_salt)
    '''Salt for the encrypted master key.

    When creating a new vault, it is **strongly recommended** to leave
    this unspecified. By default, a strong, unique, random salt will be
    autogenerated.
    '''

    def unseal(self, master_password: bytes, kdf: Argon2idKDF) -> _Fernet:
        '''Unseal the vault's master key.'''

        # Deserialize and encode the encrypted master key.
        encrypted_master: bytes = _urlsafe_b64decode(self.seal.encode())

        # Derive our protection key from the master password.
        # Create a fernet instance from the protection key.
        protection_key: bytes = kdf.derive(master_password, self.salt.encode())
        protection_fernet = _Fernet(protection_key)

        # Decrypt the vault's master key.
        # Create and return the final Fernet for vault operations.
        master_key: bytes = protection_fernet.decrypt(encrypted_master)
        master_fernet = _Fernet(master_key)
        return master_fernet

    @classmethod
    def create(cls, master_password: bytes, kdf: Argon2idKDF):
        '''Create a new master key, protected by a master vault password.'''

        # Generate a strong encryption key for the vault.
        master_key: bytes = _Fernet.generate_key()

        # Derive a protection key from the master password
        salt: str = new_salt()
        protection_key: bytes = kdf.derive(master_password, salt.encode())

        # Encrypt the vault's master key.
        fernet = _Fernet(protection_key)
        encrypted_master: bytes = fernet.encrypt(master_key)

        # Base64-encode the encrypted master key.
        # Return the new encrypted MasterKey instance.
        encoded_master: str = _urlsafe_b64encode(encrypted_master).decode()
        return cls(
            seal=encoded_master,
            salt=salt,
        )


@_define
class PV:
    '''The PV Secrets Vault.'''

    master_key: MasterKey = _field()
    '''The encrypted master key for this vault.

    The vault's master key is protected by a master password. When
    creating a new vault, use `PV.init()` to set the master password.
    '''

    argon2id: Argon2idKDF = _Factory(Argon2idKDF)
    '''Argon2id KDF instance with parameters.

    Most users are **strongly** recommended to leave this as the
    default, however, power users may choose to override the default
    configuration at their own peril.
    '''

    secrets: dict[str, Secret] = _field(factory=dict) #type:ignore - Linter Error
    '''The inner secrets store.

    It is strongly recommended to leave this as the default and use the
    built-in methods, such as `PV.store_secret()`, to interact with
    this store.
    '''

    version: int = _field(default=PV_VERSION)
    '''Database Version.

    It it recommended to leave this as the default.
    '''

    def store_secret(self, key: str, value: str, master_password: str) -> None:
        '''Store a secret in the database.'''

        # Create a secret and seal it.
        fernet = self.master_key.unseal(master_password.encode(), self.argon2id)
        sealed_secret = Secret(value).seal(fernet)

        # Update the database on `key`.
        self.secrets.update({
            key: sealed_secret,
        })

    def read_secret(self, key: str, master_password: str) -> str:
        '''Read a secret from the database.'''

        # Unseal the master key.
        # Retrieve the sealed secret from the database.
        fernet = self.master_key.unseal(master_password.encode(), self.argon2id)
        sealed_secret: _Optional[Secret] = self.secrets.get(key)
        if not sealed_secret:
            raise KeyError(f'Secret {key} does not exist.', key)

        # Unseal the secret and return it.
        unsealed_secret: Secret = sealed_secret.unseal(fernet)
        return unsealed_secret.secret

    def list_secrets(self) -> list[str]:
        '''List all secrets in the database.'''

        # Return a list of stored keys.
        return [key for key in self.secrets.keys()]

    def delete_secret(self, key: str) -> None:
        '''Delete a secret from the database.'''

        # Remove the secret from the vault.
        _ = self.secrets.pop(key, None)

    def save(self, path: _Path) -> None:
        '''Save the database as JSON to `path`.'''

        # Serialize and write the database.
        serialized_pv = _unstructure(self) #type:ignore - Fundamentally untyped.
        with open(path, 'w') as fd:
            _json.dump(serialized_pv, fd)

    @classmethod
    def load(cls, path: _Path) -> 'PV':
        '''Load the database as JSON from `path`.'''

        # Read in the serialized database.
        with open(path, 'r') as fd:
            serialized_pv = _json.load(fd) #type:ignore - Fundamentally untyped.

        # Deserialize and return the database
        return _structure(serialized_pv, cls)

    @classmethod
    def init(cls, master_password: str, argon2id: _Optional[Argon2idKDF] = None):
        '''Create a new vault with the given master password.

        This method creates a new vault with the given master password,
        optionally with Argon2id parameters. For most users, it is
        strongly recommended to leave the Argon2id parameters as default.
        '''

        # Use default Argon2id parameters if not specified.
        if not argon2id:
            argon2id = Argon2idKDF()

        # Create the vault's master key.
        master_key = MasterKey.create(master_password.encode(), argon2id)

        # Initialize the vault.
        return cls(
            master_key=master_key,
            argon2id=argon2id,
        )
