'''# The PV Secrets Vault

Copyright (c) 2025 @ctx400. All rights reserved.

Licensed for use under the terms of the MIT license.
(https://opensource.org/license/mit)

A simple, secure vault for storing arbitrary secrets, serializable to
JSON, and easy to integrate into other projects.

## Basic Usage Recipies

```py
# Create a new vault
pv = PV()
pv.save('pv.json')

# Load an existing vault
pv = PV.load('pv.json')

# Create new secrets
pv.store_secret('mykey', 'mysecret', b'master_password')
pv.store_secret('google', 'mygooglepassword123', b'master_password')
pv.save('pv.json')

# List all secrets
print(pv.list_secrets())

# Read a secret
print(pv.read_secret('mykey', b'master_password'))

# Delete a secret
pv.delete_secret('mykey')
```
'''

# stdlib imports
import json
import secrets
from pathlib import Path
from base64 import urlsafe_b64encode, urlsafe_b64decode
from typing import Optional

# 3rd-party imports
from cattrs import structure, unstructure
from attrs import define, field, Factory
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives.kdf.argon2 import Argon2id


PV_VERSION: int = 1
'''Current PV major version.

This version number will increase after any breaking change to the
vault structure or its operation.
'''


def new_salt(length: int = 16) -> str:
    '''Generates a base64-encoded random salt.'''

    salt: bytes = secrets.token_bytes(length)
    encoded: bytes = urlsafe_b64encode(salt)
    return encoded.decode()


@define(frozen=True)
class Argon2idKDF:
    '''Parameters for PV's Key Deriviation Function (KDF).

    PV uses Argon2id, a very strong hash function
    designed intentionally to be very slow, very memory intensive,
    and very compute expensive. This makes it an ideal choice for
    brute-force and dictionary-resistant password hashing and
    cryptographic key derivation.

    These parameter values are secure by default, however, the end-user
    is free to tune them to their liking. However, it is **strongly**
    recommended not to change parameters if you don't know what you're
    doing.

    **REFERENCE**: Secure defaults are from OWASP. See the
    [OWASP CheatSheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#argon2id)
    for quick reference.
    '''

    memory_cost: int = 94208
    '''Memory to use per hashing operation, in Kibibytes (KiB).

    Greater memory usage makes it more difficult to run
    password-cracking operations.
    '''

    iterations: int = 2
    '''Number of hashing rounds to perform.

    A greater number of iterations increases the time it takes to
    compute a hash, slowing down adversaries.
    '''

    parallelism: int = 1
    '''Number of parallel threads to use.
    It is recommended to keep this value low.
    '''

    def derive(self, password: bytes, salt: bytes) -> bytes:
        '''Generate an encryption derivation key.

        Make sure you are using a securely-generated, random, and unique
        salt value, such as generated by the `new_salt()` function.

        It is recommended to use a long, complex master password, or a
        passphrase consisting of at least 6-8 random words. Always use
        best practices for choosing a password.
        '''

        kdf = Argon2id(
            salt=salt,
            memory_cost=self.memory_cost,
            iterations=self.iterations,
            lanes=self.parallelism,
            length=32,
        )
        derived_key: bytes = kdf.derive(password)
        encoded_key: bytes = urlsafe_b64encode(derived_key)
        return encoded_key



@define(frozen=True)
class Secret:
    '''An encrypted secret stored in a PV database.'''

    secret: str = field()
    '''The secret to encrypt/decrypt.'''

    salt: str = Factory(new_salt)
    '''The salt value applied to the KDF for this secret.

    If not specified, a random, unique salt will be generated
    using `new_salt()`.
    '''

    def seal(self, argon2id: Argon2idKDF, password: bytes) -> 'Secret':
        '''Returns an encrypted (sealed) `Secret` instance.'''

        # Derive an encryption key using the password.
        encoded_salt: bytes = self.salt.encode()
        secret_key: bytes = argon2id.derive(password, encoded_salt)

        # Encrypt the secret.
        fernet = Fernet(secret_key)
        encrypted_secret: bytes = fernet.encrypt(self.secret.encode())

        # Serialize and decode the secret.
        serialized_secret: bytes = urlsafe_b64encode(encrypted_secret)
        decoded_secret: str = serialized_secret.decode()

        # Return the sealed secret.
        return Secret(
            salt=self.salt,
            secret=decoded_secret,
        )

    def unseal(self, argon2id: Argon2idKDF, password: bytes) -> 'Secret':
        '''Returns a plaintext (unsealed) `Secret` instance.'''

        # Encode and deserialize the secret.
        encoded_secret: bytes = self.secret.encode()
        deserialized_secret: bytes = urlsafe_b64decode(encoded_secret)

        # Derive the encryption key using the password.
        encoded_salt: bytes = self.salt.encode()
        secret_key: bytes = argon2id.derive(password, encoded_salt)

        # Decrypt and decode the secret.
        fernet = Fernet(secret_key)
        plaintext_secret: bytes = fernet.decrypt(deserialized_secret)
        decoded_secret: str = plaintext_secret.decode()

        # Return the unsealed secret.
        return Secret(
            salt=self.salt,
            secret=decoded_secret,
        )


@define
class PV:
    '''The PV Secrets Vault.'''

    version: int = field(default=PV_VERSION)
    '''Database Version.

    It it recommended to leave this as the default.
    '''

    argon2id: Argon2idKDF = Factory(Argon2idKDF)
    '''Argon2id KDF instance with parameters.

    Most users are **strongly** recommended to leave this as the
    default, however, power users may choose to override the default
    configuration at their own peril.
    '''


    secrets: dict[str, Secret] = Factory(dict) #type:ignore - Linter Error
    '''The inner secrets store.

    It is strongly recommended to leave this as the default and use the
    built-in methods, such as `PV.store_secret()`, to interact with
    this store.
    '''

    def store_secret(self, key: str, value: str, master_password: bytes) -> None:
        '''Store a secret in the database.'''

        # Create a secret and seal it.
        # Securely read a master password from stdin.
        sealed_secret = Secret(value).seal(self.argon2id, master_password)

        # Update the database on `key`.
        self.secrets.update({
            key: sealed_secret,
        })

    def read_secret(self, key: str, master_password: bytes) -> str:
        '''Read a secret from the database.'''

        # Retrieve the sealed secret from the database.
        sealed_secret: Optional[Secret] = self.secrets.get(key)
        if not sealed_secret:
            raise KeyError(f'Secret {key} does not exist.', key)

        # Unseal the secret and return it.
        # Securely read a master password from stdin.
        unsealed_secret: Secret = sealed_secret.unseal(self.argon2id, master_password)
        return unsealed_secret.secret

    def list_secrets(self) -> list[str]:
        '''List all secrets in the database.'''
        return [key for key in self.secrets.keys()]

    def delete_secret(self, key: str) -> None:
        '''Delete a secret from the database.'''
        _ = self.secrets.pop(key, None)

    def save(self, path: Path) -> None:
        '''Save the database as JSON to `path`.'''

        # Serialize and write the database.
        serialized_pv = unstructure(self) #type:ignore - Fundamentally untyped.
        with open(path, 'w') as fd:
            json.dump(serialized_pv, fd)

    @classmethod
    def load(cls, path: Path) -> 'PV':
        '''Load the database as JSON from `path`.'''

        # Read in the serialized database.
        with open(path, 'r') as fd:
            serialized_pv = json.load(fd) #type:ignore - Fundamentally untyped.

        # Deserialize and return the database
        return structure(serialized_pv, cls)
